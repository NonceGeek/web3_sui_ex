# Hello Blockchain

```elixir
Mix.install([:poison, :jason, {:web3_move_ex, "~> 0.2.0"}])
```

## 0x00 Main Code

`hello_blockchain.move` :

```rust
module hello_blockchain::message {
    use std::error;
    use std::signer;
    use std::string;
    use aptos_framework::account;
    use aptos_framework::event;

//:!:>resource
    struct MessageHolder has key {
        message: string::String,
        message_change_events: event::EventHandle<MessageChangeEvent>,
    }
//<:!:resource

    struct MessageChangeEvent has drop, store {
        from_message: string::String,
        to_message: string::String,
    }

    /// There is no message present
    const ENO_MESSAGE: u64 = 0;

    #[view]
    public fun get_message(addr: address): string::String acquires MessageHolder {
        assert!(exists<MessageHolder>(addr), error::not_found(ENO_MESSAGE));
        *&borrow_global<MessageHolder>(addr).message
    }

    public entry fun set_message(account: signer, message: string::String)
    acquires MessageHolder {
        let account_addr = signer::address_of(&account);
        if (!exists<MessageHolder>(account_addr)) {
            move_to(&account, MessageHolder {
                message,
                message_change_events: account::new_event_handle<MessageChangeEvent>(&account),
            })
        } else {
            let old_message_holder = borrow_global_mut<MessageHolder>(account_addr);
            let from_message = *&old_message_holder.message;
            event::emit_event(&mut old_message_holder.message_change_events, MessageChangeEvent {
                from_message,
                to_message: copy message,
            });
            old_message_holder.message = message;
        }
    }

    #[test(account = @0x1)]
    public entry fun sender_can_set_message(account: signer) acquires MessageHolder {
        let addr = signer::address_of(&account);
        aptos_framework::account::create_account_for_test(addr);
        set_message(account,  string::utf8(b"Hello, Blockchain"));

        assert!(
          get_message(addr) == string::utf8(b"Hello, Blockchain"),
          ENO_MESSAGE
        );
    }
}

```

<!-- livebook:{"break_markdown":true} -->

`hello_blockchain_test.move` :

```rust
#[test_only]
module hello_blockchain::message_tests {
    use std::signer;
    use std::unit_test;
    use std::vector;
    use std::string;

    use hello_blockchain::message;

    fun get_account(): signer {
        vector::pop_back(&mut unit_test::create_signers_for_testing(1))
    }

    #[test]
    public entry fun sender_can_set_message() {
        let account = get_account();
        let addr = signer::address_of(&account);
        aptos_framework::account::create_account_for_test(addr);
        message::set_message(account,  string::utf8(b"Hello, Blockchain"));

        assert!(
          message::get_message(addr) == string::utf8(b"Hello, Blockchain"),
          0
        );
    }
}

```

## 0x01 Smart Contract Code Analysis

### 1.1 ç»“æ„ä½“

> ğŸ’¡ **èƒ½åŠ›**
> 
> Move ä¸­çš„ç»“æ„å¯ä»¥è¢«èµ‹äºˆä¸åŒçš„èƒ½åŠ›ï¼Œæè¿°å¯ä»¥ç”¨è¯¥ç±»å‹åšä»€ä¹ˆã€‚ å­˜åœ¨æœ‰å››ç§ä¸åŒçš„èƒ½åŠ›ï¼š
> 
> **copy:** å…·æœ‰è¢«å¤åˆ¶èƒ½åŠ›çš„ç±»å‹çš„å€¼ã€‚ åœ°ç† ID å°†æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç”¨ä¾‹ã€‚ NFT ä¸åº”è¯¥æœ‰è¿™ä¸ªèƒ½åŠ›ã€‚
> 
> **drop:** å…·æœ‰è¿™ç§èƒ½åŠ›çš„ç±»å‹çš„å€¼è¢«å¼¹å‡º/åˆ é™¤ã€‚
> 
> **store:** å…·æœ‰è¿™ç§èƒ½åŠ›çš„ç±»å‹çš„å€¼å¯ä»¥ä¿å­˜æˆ–å­˜å‚¨åœ¨å…¨å±€å­˜å‚¨çš„ç»“æ„ä¸­ã€‚
> 
> **key:** ç”¨ä½œå…¨å±€å­˜å‚¨æ“ä½œçš„é”®çš„ç±»å‹ã€‚ æœ‰äº†è¿™ä¸ªèƒ½åŠ›ï¼Œä¸€ä¸ªå€¼å¯ä»¥ä½œä¸ºé¡¶çº§é¡¹ç›®å­˜å‚¨åœ¨ä¸€ä¸ªå¸æˆ·ä¸­ã€‚

> ğŸ’¡ **Abilities**
> 
> Structures in Move can be given different abilities that describe what can be done with that type. There are four different abilities that allow:
> 
> **copy:** values of types with this ability to be copied. A geographic ID would be a good use case. NFTs should not have this ability.
> 
> **drop:** values of types with this ability to be popped/dropped.
> 
> **store:** values of types with this ability to be saved or stored inside a struct in global storage.
> 
> **key:** the type to serve as a key for global storage operations. With this ability, a value can be stored as a top-level item inside an account.

```
struct MessageHolder has key {
    message: string::String,
    message_change_events: event::EventHandle<MessageChangeEvent>,
}
```

<!-- livebook:{"break_markdown":true} -->

### 1.2 Events

```
struct MessageChangeEvent has drop, store {
    from_message: string::String,
    to_message: string::String,
}
```

<!-- livebook:{"break_markdown":true} -->

### 1.3 Functions

> ğŸ’¡ **è·å–**
> 
> ä»»ä½•æ—¶å€™ä½ éœ€è¦ä½¿ç”¨ä»»ä½•å…¨å±€èµ„æºï¼Œæ¯”å¦‚ä¸€ä¸ªç»“æ„ï¼Œä½ åº”è¯¥é¦–å…ˆè·å–å®ƒã€‚ ä¾‹å¦‚ï¼Œå­˜å…¥å’Œæå–ä¸€ä¸ª NFT éƒ½ä¼šè·å– TokenStoreã€‚ å¦‚æœæ‚¨åœ¨ä¸åŒçš„æ¨¡å—ä¸­æœ‰ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ¨¡å—å†…éƒ¨çš„å‡½æ•°æ¥è·å–èµ„æºï¼Œåˆ™ä¸å¿…å°†ç¬¬ä¸€ä¸ªå‡½æ•°æ ‡è®°ä¸º acquires()ã€‚
> 
> è¿™ä½¿å¾—æ‰€æœ‰æƒæ¸…æ™°ï¼Œå› ä¸ºèµ„æºå­˜å‚¨åœ¨å¸æˆ·å†…ã€‚ å¸æˆ·å¯ä»¥å†³å®šæ˜¯å¦å¯ä»¥åœ¨é‚£é‡Œåˆ›å»ºèµ„æºã€‚ å®šä¹‰è¯¥èµ„æºçš„æ¨¡å—æœ‰æƒè¯»å–å’Œä¿®æ”¹è¯¥ç»“æ„ã€‚ å› æ­¤è¯¥æ¨¡å—å†…çš„ä»£ç éœ€è¦æ˜¾å¼è·å–è¯¥ç»“æ„ã€‚
> 
> å°½ç®¡å¦‚æ­¤ï¼Œåœ¨ Move ä¸­å€Ÿç”¨æˆ–ç§»åŠ¨çš„ä»»ä½•åœ°æ–¹ï¼Œæ‚¨éƒ½ä¼šè‡ªåŠ¨è·å–èµ„æºã€‚ ä¸ºæ¸…æ¥šèµ·è§ï¼Œä½¿ç”¨ acquire æ˜ç¡®åŒ…å«ã€‚ åŒæ ·ï¼Œexists() å‡½æ•°ä¸éœ€è¦ acquires() å‡½æ•°ã€‚
> 
> æ³¨æ„ï¼šæ‚¨å¯ä»¥ä»æ‚¨è‡ªå·±çš„æ¨¡å—ä¸­å®šä¹‰çš„ç»“æ„ä¸­çš„ä»»ä½•å¸æˆ·å€Ÿç”¨æ¨¡å—ä¸­çš„å…¨å±€ã€‚ æ‚¨ä¸èƒ½åœ¨æ¨¡å—å¤–å€Ÿç”¨ globalã€‚

```
  #[view]
  public fun get_message(addr: address): string::String acquires MessageHolder {
      assert!(exists<MessageHolder>(addr), error::not_found(ENO_MESSAGE));
      *&borrow_global<MessageHolder>(addr).message
  }

  public entry fun set_message(account: signer, message: string::String)
  acquires MessageHolder {
      let account_addr = signer::address_of(&account);
      if (!exists<MessageHolder>(account_addr)) {
          move_to(&account, MessageHolder {
              message,
              message_change_events: account::new_event_handle<MessageChangeEvent>(&account),
          })
      } else {
          let old_message_holder = borrow_global_mut<MessageHolder>(account_addr);
          let from_message = *&old_message_holder.message;
          event::emit_event(&mut old_message_holder.message_change_events, MessageChangeEvent {
              from_message,
              to_message: copy message,
          });
          old_message_holder.message = message;
      }
  }

```
